
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

// This file is autogenerated! Do not change!

#ifndef OPENTITAN_HW_IP_AES_PRE_DV_AES_TB_CPP_AES_TLUL_SEQUENCE_AUTO_H_
#define OPENTITAN_HW_IP_AES_PRE_DV_AES_TB_CPP_AES_TLUL_SEQUENCE_AUTO_H_

#include "aes_tlul_sequence_common.h"
#include "crypto.h"
static const int num_transactions_max = 1+2+16 +1*(4+1+4+1) + 6;           // init, set+mode+key, data-loop, clear

static const TLI tl_i_transactions[num_transactions_max] = {
    {true, 4, 0, 2, 0, AES_STATUS, 0xF, 0x0, 0, true},                      // read status
    // AES-128
    {true, 0, 0, 2, 0, AES_CONFIG, 0xF,                                     // write AES_CONFIG, set lowest 8 bits
     (0x0 << AES_CTRL_MANUAL_OPERATION_OFFSET) |                            // start automatic, do not oveerwrite output
         (0x1 << AES_CTRL_KEY_LEN_OFFSET) |                                 // AES-128 (1), [AES-192 (2), AES-256 (4)]
         (kCryptoAesEcb << AES_CTRL_MODE_OFFSET) | 0x1,                     // ECB + ENC
     0, true},  // ctrl - decrypt, 128-bit
    {true, 0, 0, 2, 0, AES_CONFIG, 0xF,                                     // we are using shaddow config
     (0x0 << AES_CTRL_MANUAL_OPERATION_OFFSET) |                            // write everything twice
         (0x1 << AES_CTRL_KEY_LEN_OFFSET) |                                 // with same parameters
         (kCryptoAesEcb << AES_CTRL_MODE_OFFSET) | 0x1,
     0, true},  // ctrl - decrypt, 128-bit
    {true, 0, 0, 2, 0, AES_KEY_SHARE0_0 + 0x00, 0xF, 0x16157e2b, 0, true},  // write key0
    {true, 0, 0, 2, 0, AES_KEY_SHARE0_0 + 0x04, 0xF, 0xa6d2ae28, 0, true},  // write key1
    {true, 0, 0, 2, 0, AES_KEY_SHARE0_0 + 0x08, 0xF, 0x8815f7ab, 0, true},  // write key2
    {true, 0, 0, 2, 0, AES_KEY_SHARE0_0 + 0x0C, 0xF, 0x3c4fcf09, 0, true},  // write key3
    {true, 0, 0, 2, 0, AES_KEY_SHARE0_0 + 0x10, 0xF, 0x13121110, 0, true},  // all key regs must be written...
    {true, 0, 0, 2, 0, AES_KEY_SHARE0_0 + 0x14, 0xF, 0x17161514, 0, true},  // ...even if unused in AES-128...
    {true, 0, 0, 2, 0, AES_KEY_SHARE0_0 + 0x18, 0xF, 0x1B1A1918, 0, true},  // ...even if unused in AES-192...
    {true, 0, 0, 2, 0, AES_KEY_SHARE0_0 + 0x1c, 0xF, 0x1F1E1D1C, 0, true},  // ...write "random" values

    {true, 0, 0, 2, 0, AES_KEY_SHARE1_0 + 0x00, 0xF, 0x0, 0, true},         // all key shares must be written - even if there's no masking
    {true, 0, 0, 2, 0, AES_KEY_SHARE1_0 + 0x04, 0xF, 0x0, 0, true},         // we do not have any masked key shares - so XOR 0
    {true, 0, 0, 2, 0, AES_KEY_SHARE1_0 + 0x08, 0xF, 0x0, 0, true},         // we do not have any masked key shares - so XOR 0
    {true, 0, 0, 2, 0, AES_KEY_SHARE1_0 + 0x0C, 0xF, 0x0, 0, true},         // we do not have any masked key shares - so XOR 0
    {true, 0, 0, 2, 0, AES_KEY_SHARE1_0 + 0x10, 0xF, 0x0, 0, true},         // all key shares must be written...
    {true, 0, 0, 2, 0, AES_KEY_SHARE1_0 + 0x14, 0xF, 0x0, 0, true},         // ...even if unused in AES-128...
    {true, 0, 0, 2, 0, AES_KEY_SHARE1_0 + 0x18, 0xF, 0x0, 0, true},         // ...even if unused in AES-192...
    {true, 0, 0, 2, 0, AES_KEY_SHARE1_0 + 0x1c, 0xF, 0x0, 0, true},         // ...so write zeros to be XORed

    {true, 0, 0, 2, 0, AES_DATA_IN_0 + 0x0, 0xF, 0x5b32f5e1, 0, true},      // write data0
    {true, 0, 0, 2, 0, AES_DATA_IN_0 + 0x4, 0xF, 0x635c3fdc, 0, true},      // write data1
    {true, 0, 0, 2, 0, AES_DATA_IN_0 + 0x8, 0xF, 0x3c80e94b, 0, true},      // write data2
    {true, 0, 0, 2, 0, AES_DATA_IN_0 + 0xC, 0xF, 0xc89464c4, 0, true},      // write data3 ==> one AES Block has been sent => we can start over

    {true, 4, 0, 2, 0, AES_STATUS, 0xF, 0x0, 0, true},                      // read status
    {true, 4, 0, 2, 0, AES_DATA_OUT_0 + 0x0, 0xF, 0x0, 0, true},            // read data0
    {true, 4, 0, 2, 0, AES_DATA_OUT_0 + 0x4, 0xF, 0x0, 0, true},            // read data1
    {true, 4, 0, 2, 0, AES_DATA_OUT_0 + 0x8, 0xF, 0x0, 0, true},            // read data2
    {true, 4, 0, 2, 0, AES_DATA_OUT_0 + 0xC, 0xF, 0x0, 0, true},            // read data3 ==> one AES Block has been read => we can start over
    {true, 4, 0, 2, 0, AES_STATUS, 0xF, 0x0, 0, true},                      // read status
    
    // Clear
    {true, 0, 0, 2, 0, AES_TRIGGER, 0xF, 0x1E, 0, true},                    // clear (normally 0xE should be sufficient)
    {true, 4, 0, 2, 0, AES_STATUS, 0xF, 0x0, 0, true},                      // read status
    {true, 4, 0, 2, 0, AES_DATA_OUT_0 + 0x0, 0xF, 0x0, 0, true},            // do one final reading of the AES-regs
    {true, 4, 0, 2, 0, AES_DATA_OUT_0 + 0x4, 0xF, 0x0, 0, true},            // should now be cleared
    {true, 4, 0, 2, 0, AES_DATA_OUT_0 + 0x8, 0xF, 0x0, 0, true},            // with random values
    {true, 4, 0, 2, 0, AES_DATA_OUT_0 + 0xC, 0xF, 0x0, 0, true},            // this is done by the AES-IP
};
static const int num_responses_max = 1 + 1*6 + 5;    // init, data-loop, clear

static const EXP_RESP tl_o_exp_resp[num_responses_max] = {
    {1 << AES_STATUS_IDLE_OFFSET,
     1 << AES_STATUS_IDLE_OFFSET},                    // we should be idle

    {1 << AES_STATUS_OUTPUT_VALID_OFFSET,
     1 << AES_STATUS_OUTPUT_VALID_OFFSET},            // we've started a new encryption, thus there should be valid output
    {CHECK_DATA_OUT ? 0xFFFFFFFF : 0x0, 0x05bfea5c},  // read data0
    {CHECK_DATA_OUT ? 0xFFFFFFFF : 0x0, 0x38429ce4},  // read data1
    {CHECK_DATA_OUT ? 0xFFFFFFFF : 0x0, 0xa2a8f439},  // read data2
    {CHECK_DATA_OUT ? 0xFFFFFFFF : 0x0, 0xfc0e2e5b},  // read data3
    {1 << AES_STATUS_OUTPUT_VALID_OFFSET,
     0},                                              // now we've read every thing. output shouldn't be valid anymore
    
    {1 << AES_STATUS_IDLE_OFFSET,
     1 << AES_STATUS_IDLE_OFFSET},                    // status shows idle
    {0x0, 0x0},                                       // data_out0 should be cleared to random value
    {0x0, 0x0},                                       // data_out1 should be cleared to random value
    {0x0, 0x0},                                       // data_out2 should be cleared to random value
    {0x0, 0x0},                                       // data_out3 should be cleared to random value
};

#endif  // OPENTITAN_HW_IP_AES_PRE_DV_AES_TB_CPP_AES_TLUL_SEQUENCE_AUTO_H_
